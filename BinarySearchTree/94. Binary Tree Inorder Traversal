/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}


 Complexity - O(N)
 Space - O(1)

We can visit each node and then make connection with in-order predecar of that node and current node , once connection is made 
we will go more left , once we have made the connection where left is null , now we will print the elements
first print extreme left , then go right of that

right must have the connection with previous current so it will go previous current
once again we will find predesor of current element and this time right node will be equal to current

upon finding this we can say we are revisting that node so we move curr to right and print and set that right to null again

dry run

cur=1
ans = 4 2 6 5 7

cur=1
pre=7    7-1

cur=2
pre=4  4-2

cur=4       
pushback

cur=2
pre=4
pushback 4 x 2

cur=5
prev=6  6-5

cur=6
pushback

cur = 5
pusback 

cur=7
push_back

cur=1



 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        

    TreeNode* cur = root;
    vector<int>ans;
    while(cur != NULL)
      if(cur->left != NULL){

        TreeNode* pre= cur->left;
        while(pre->right && pre->right != cur)pre=pre->right;
        if(!pre->right){
            pre->right = cur;
            cur=cur->left;
        }
        else{
            pre->right=NULL;
            ans.push_back(cur->val);
            cur=cur->right;
        }
      }
      else{
        ans.push_back(cur->val);
        cur=cur->right;
      }
      return ans;
    }
};
